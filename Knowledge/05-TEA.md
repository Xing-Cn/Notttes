# TEA 加密算法
*基础知识*

### 基本概念

| 概念           | 说明                                    |
|----------------|----------------------------------------|
| 分组大小       | 64 bit(8 字节), 分成 2×32-bit 处理       |
| 密钥大小       | 128 bit(16 字节), 通常为 4×32-bit        |
| 加密轮数       | 32 轮(经典 TEA), 可调整                  |
| 算法特点       | 结构简单, 实现短小, 适合练习逆向/CTF       |

TEA 的一个典型原型函数(加密):

``` C++
void TEA_encrypt(uint32_t v[2], const uint32_t k[4]) {
    uint32_t v0 = v[0], v1 = v[1];
    uint32_t sum = 0, delta = 0x9E3779B9;
    for (int i = 0; i < 32; i++) {
        sum += delta;
        v0 += ((v1 << 4) + k[0]) ^ (v1 + sum) ^ ((v1 >> 5) + k[1]);
        v1 += ((v0 << 4) + k[2]) ^ (v0 + sum) ^ ((v0 >> 5) + k[3]);
    }
    v[0] = v0; v[1] = v1;
}
```

> 常见变体 : 有的实现会让 `sum` 从 `0xC6EF3720` 递减, 或者微调轮数 / key 使用顺序

---

### 数据块与字节序

在 x86/x86_64 这类**小端序**平台上:

- 64-bit 块通常拆成两个 32-bit:
  - `v[0]` = **低 32 位**
  - `v[1]` = **高 32 位**
- 128-bit 密钥通常视为 4×32-bit:
  - `k[0]`, `k[1]`, `k[2]`, `k[3]` 按内存从低到高依次读取

| 操作示例                     | 说明                          |
|-----------------------------|-------------------------------|
| `uint64_t x = 0x1122334455667788;` | 逻辑值，从高到低写成 0x11..88 |
| 内存实际字节顺序            | `88 77 66 55 44 33 22 11`            |
| TEA 里的 `v[0]`             | `0x55667788` (低 32 位)             |
| TEA 里的 `v[1]`             | `0x11223344` (高 32 位)             |

---

### 解密函数(与加密完全对称)

与上面加密函数对应的解密(经典 TEA)：

``` C++
void TEA_decrypt(uint32_t v[2], const uint32_t k[4]) {
    uint32_t v0 = v[0], v1 = v[1];
    uint32_t delta = 0x9E3779B9;
    uint32_t sum = delta * 32;        // 0xC6EF3720
    for (int i = 0; i < 32; i++) {
        v1 -= ((v0 << 4) + k[2]) ^ (v0 + sum) ^ ((v0 >> 5) + k[3]);
        v0 -= ((v1 << 4) + k[0]) ^ (v1 + sum) ^ ((v1 >> 5) + k[1]);
        sum -= delta;
    }
    v[0] = v0; v[1] = v1;
}
```

> 与加密的差别:  
> - `sum` 初值为 `delta * 32`, 逐步递减  
> - 每轮两条更新公式的顺序反过来 + 改成减法

---

### CTF / 逆向中的常见坑点

| 坑点                     | 说明                                                                 |
|--------------------------|----------------------------------------------------------------------|
| 伪装 key 字符串          | `.data` 提示性字符串其实只是 "笑话", 真正 key 在启动阶段被覆盖        |
| main 前的初始化          | key 通常在 `init_key()`, 构造函数, `.init_array` 中被写入/修改       |
| 字节序 / 块拆分错误      | 64-bit 常量要按 "小端：低 32 → v[0], 高 32 → v[1]" 来拆              |
| TEA 变种 / 轮数修改      | 有些题会改轮数, 调换 k 的位置, 调整 sum 增减方式                     |
| 用密文做对比             | 程序中常见 `encrypt(block) == 常量`, 逆向时要把常量当 "密文" 来解密     |

---

### Python 示例 : 用 TEA 解密 3 个块

下面是一个 Python 版 TEA 解密示例(32 轮，标准版), 配合 CTF 常见的拆块形式:

```python
DELTA = 0x9E3779B9

def tea_decrypt(v, k):
    v0, v1 = v
    sum_ = (DELTA * 32) & 0xffffffff  # 0xC6EF3720
    for _ in range(32):
        v1 = (v1 - (((v0 << 4) + k[2]) ^ (v0 + sum_) ^ ((v0 >> 5) + k[3]))) & 0xffffffff
        v0 = (v0 - (((v1 << 4) + k[0]) ^ (v1 + sum_) ^ ((v1 >> 5) + k[1]))) & 0xffffffff
        sum_ = (sum_ - DELTA) & 0xffffffff
    return [v0, v1]
```

假设有 3 个 64-bit 密文常量（典型 CTF 结构）：

```python
# 每个 [低32, 高32] 代表一个 64-bit 块
blocks = [
    [0xE66A6B7B, 0xA3ECA28E],
    [0x6CCF6CF4, 0x99043B89],
    [0x7EFD20CC, 0xD5536FC9],
]

# 真实 key : 16 字节, 按小端拆成 4×32-bit
key = [
    0x73696874,  # 't','h','i','s'
    0x5F73695F,  # '_','i','_','s'
    0x6C616572,  # 'r','e','a','l'
    0x21796B5F,  # '_','k','y','!'
]
```

拼出明文(每块 8 字节, 共 24 字节):

```python
import struct

flag_bytes = b""
for blk in blocks:
    p0, p1 = tea_decrypt(blk, key)
    # 每个 32 位用小端打包成 8 字节
    flag_bytes += struct.pack("<II", p0, p1)

print(flag_bytes)                    # 原始字节
print(flag_bytes.decode(errors="ignore"))  # 如果是 ASCII/UTF-8, 一般能直接看到 flag
```

---

### 逆向 / CTF 操作小结

```bash
# 常见流程思路(非真实命令)
1. 在 IDA 中：
   - 找 `.data` 里的可疑 key / 字符串
   - 看 Xrefs，找到 `init_key` / 构造函数 / .init_array
   - 确认 key 在运行时被改成什么样(字节级)

2. 分析加解密函数：
   - 确认是否为 TEA(看 sum, delta, 循环结构)
   - 对照 k[0..3] 的使用方式, 推导出正确解密函数

3. 编写脚本：
   - 按 "小端 : 低 32 为块的 v[0], 高 32 为 v[1]" 拆密文
   - 用运行时 key 做 TEA 解密, 拼接得到明文 / flag
```

> 实战经验:  
> 遇到提示 “What happened before `main()`?”，**优先检查构造函数 / init 函数是不是在偷偷改 key**，不要被 `.data` 里的 "看起来很像 key 的字符串" 迷惑。